#include <CapacitiveSensor.h>

#include <MozziGuts.h>
#include <Oscil.h> // oscillator
#include <tables/cos2048_int8.h> // table for Oscils to play
#include <Smooth.h>
#include <AutoMap.h> // maps unpredictable inputs to a range

// desired carrier frequency max and min, for AutoMap
const int MIN_CARRIER_FREQ = 22;
const int MAX_CARRIER_FREQ = 3040;

// desired intensity max and min, for AutoMap, note they're inverted for reverse dynamics
const int MIN_INTENSITY = 890;
const int MAX_INTENSITY = 10;

// desired mod speed max and min, for AutoMap, note they're inverted for reverse dynamics
const int MIN_MOD_SPEED = 3000;
const int MAX_MOD_SPEED = 1;

AutoMap kMapCarrierFreq(0, 2023, MIN_CARRIER_FREQ, MAX_CARRIER_FREQ);
AutoMap kMapIntensity(0, 2023, MIN_INTENSITY, MAX_INTENSITY);
AutoMap kMapModSpeed(0, 2023, MIN_MOD_SPEED, MAX_MOD_SPEED);

// const int KNOB_PIN = 0; // set the input for the knob to analog pin 0
// const int LDR1_PIN=1; // set the analog input for fm_intensity to pin 1
// const int LDR2_PIN=2; // set the analog input for mod rate to pin 2
CapacitiveSensor   cs_4_2 = CapacitiveSensor(4, 2);       // 10M resistor between pins 4 & 2, pin 2 is sensor pin, add a wire and or foil if desired
CapacitiveSensor   cs_4_6 = CapacitiveSensor(4, 6);       // 10M resistor between pins 4 & 6, pin 6 is sensor pin, add a wire and or foil
CapacitiveSensor   cs_4_8 = CapacitiveSensor(4, 8);       // 10M resistor between pins 4 & 8, pin 8 is sensor pin, add a wire and or foil

Oscil<COS2048_NUM_CELLS, AUDIO_RATE> aCarrier(COS2048_DATA);
Oscil<COS2048_NUM_CELLS, AUDIO_RATE> aModulator(COS2048_DATA);
Oscil<COS2048_NUM_CELLS, CONTROL_RATE> kIntensityMod(COS2048_DATA);

int mod_ratio = 5; // brightness (harmonics)
long fm_intensity; // carries control info from updateControl to updateAudio

// smoothing for intensity to remove clicks on transitions
float smoothness = 0.95f;
Smooth <long> aSmoothIntensity(smoothness);


boolean pause_triggered, paused = false;;
byte volume;


 

void setup() {



  cs_4_2.set_CS_AutocaL_Millis(0xFFFFFFFF);     // turn off autocalibrate on channel 1 - just as an example

  Serial.begin(115200); // set up the Serial output so we can look at the piezo values // set up the Serial output so we can look at the light level
  startMozzi(); // :))
}



void updateControl() {

  // read the knob
  long knob_value = cs_4_2.capacitiveSensor(30); // value is 0-1023
Serial.print("knob = ");
  Serial.print(knob_value);
  Serial.print("\t"); // prints a tab
  // map the knob to carrier frequency
  int carrier_freq = kMapCarrierFreq(knob_value);

  //calculate the modulation frequency to stay in ratio
  int mod_freq = carrier_freq * mod_ratio;

  // set the FM oscillator frequencies
  aCarrier.setFreq(carrier_freq);
  aModulator.setFreq(mod_freq);

  // read the light dependent resistor on the width Analog input pin
  long LDR1_value = cs_4_6.capacitiveSensor(30); // value is 0-1023

  // print the value to the Serial monitor for debugging
  Serial.print("LDR1 = ");
  Serial.print(LDR1_value);
  Serial.print("\t"); // prints a tab

  int LDR1_calibrated = kMapIntensity(LDR1_value);
  Serial.print("LDR1_calibrated = ");
  Serial.print(LDR1_calibrated);
  Serial.print("\t"); // prints a tab

  // calculate the fm_intensity
  fm_intensity = ((long)LDR1_calibrated * (kIntensityMod.next() + 128)) >> 8; // shift back to range after 8 bit multiply
  Serial.print("fm_intensity = ");
  Serial.print(fm_intensity);
  Serial.print("\t"); // prints a tab

  // read the light dependent resistor on the speed Analog input pin
  long LDR2_value = cs_4_8.capacitiveSensor(30); // value is 0-1023
  Serial.print("LDR2 = ");
  Serial.print(LDR2_value);
  Serial.print("\t"); // prints a tab

  // use a float here for low frequencies
  float mod_speed = (float)kMapModSpeed(LDR2_value) / 1000;
  Serial.print("   mod_speed = ");
  Serial.print(mod_speed);
  kIntensityMod.setFreq(mod_speed);

  Serial.println(); // finally, print a carraige return for the next line of debugging info
if (knob_value>140 || LDR1_value>100 || LDR2_value>100) {
  volume=255;
} else {
  volume=0;
}
}


AudioOutput_t updateAudio() {
  long modulation = aSmoothIntensity.next(fm_intensity) * aModulator.next();
  // return MonoOutput::from8Bit(aCarrier.phMod(modulation) * volume);
   return MonoOutput::from16Bit(aCarrier.phMod(modulation) * volume);
}


void loop() {
  int motor = 10; // motor assigned to pin 10 
  int sensorVal = analogRead(A0); // variable to store the sensor value
 
  // initialize the motor as an output.
  pinMode(motor, OUTPUT);

if (sensorVal > 50) { // when the buttonState is 0
  digitalWrite(motor, HIGH);   // turn the motor on (HIGH is the voltage level)
 }
 else { // otherwise = when the buttonState is 1
  digitalWrite(motor, LOW);    // turn the motor off by making the voltage LOW
 }
  
 audioHook();
}
